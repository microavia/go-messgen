// Code generated by messgen. DO NOT EDIT.

package message

import (
	"encoding/binary"
	"fmt"
	"math"
)

type Message10 struct {
	FieldFloat64Slice []float64
	FieldInt64Slice   []int64
	FieldUint64Slice  []uint64
	FieldFloat32Slice []float32
	FieldInt32Slice   []int32
	FieldUint32Slice  []uint32
	FieldInt16Slice   []int16
	FieldUint16Slice  []uint16
	FieldCharSlice    []byte
	FieldUint8Slice   []uint8
}

const Message10MsgId = 10
const Message10MinMsgSize = 40

func (v *Message10) MsgId() int {
	return 10
}

func (v *Message10) MsgSize() int {
	return 4 + 8*len(v.FieldFloat64Slice) + 4 + 8*len(v.FieldInt64Slice) + 4 + 8*len(v.FieldUint64Slice) + 4 + 4*len(v.FieldFloat32Slice) + 4 + 4*len(v.FieldInt32Slice) + 4 + 4*len(v.FieldUint32Slice) + 4 + 2*len(v.FieldInt16Slice) + 4 + 2*len(v.FieldUint16Slice) + 4 + 1*len(v.FieldCharSlice) + 4 + 1*len(v.FieldUint8Slice)
}

func (v *Message10) Pack(buf []byte) (int, error) {
	if len(buf) < v.MsgSize() {
		return 0, fmt.Errorf("invalid buffer size for packing Message10: %d, should be >=%d", len(buf), v.MsgSize())
	}
	ptr := 0
	binary.LittleEndian.PutUint32(buf[ptr:], uint32(len(v.FieldFloat64Slice)))
	ptr += 4
	for i := 0; i < len(v.FieldFloat64Slice); i++ {
		binary.LittleEndian.PutUint64(buf[ptr:], math.Float64bits(v.FieldFloat64Slice[i]))
		ptr += 8
	}
	binary.LittleEndian.PutUint32(buf[ptr:], uint32(len(v.FieldInt64Slice)))
	ptr += 4
	for i := 0; i < len(v.FieldInt64Slice); i++ {
		binary.LittleEndian.PutUint64(buf[ptr:], uint64(v.FieldInt64Slice[i]))
		ptr += 8
	}
	binary.LittleEndian.PutUint32(buf[ptr:], uint32(len(v.FieldUint64Slice)))
	ptr += 4
	for i := 0; i < len(v.FieldUint64Slice); i++ {
		binary.LittleEndian.PutUint64(buf[ptr:], v.FieldUint64Slice[i])
		ptr += 8
	}
	binary.LittleEndian.PutUint32(buf[ptr:], uint32(len(v.FieldFloat32Slice)))
	ptr += 4
	for i := 0; i < len(v.FieldFloat32Slice); i++ {
		binary.LittleEndian.PutUint32(buf[ptr:], math.Float32bits(v.FieldFloat32Slice[i]))
		ptr += 4
	}
	binary.LittleEndian.PutUint32(buf[ptr:], uint32(len(v.FieldInt32Slice)))
	ptr += 4
	for i := 0; i < len(v.FieldInt32Slice); i++ {
		binary.LittleEndian.PutUint32(buf[ptr:], uint32(v.FieldInt32Slice[i]))
		ptr += 4
	}
	binary.LittleEndian.PutUint32(buf[ptr:], uint32(len(v.FieldUint32Slice)))
	ptr += 4
	for i := 0; i < len(v.FieldUint32Slice); i++ {
		binary.LittleEndian.PutUint32(buf[ptr:], v.FieldUint32Slice[i])
		ptr += 4
	}
	binary.LittleEndian.PutUint32(buf[ptr:], uint32(len(v.FieldInt16Slice)))
	ptr += 4
	for i := 0; i < len(v.FieldInt16Slice); i++ {
		binary.LittleEndian.PutUint16(buf[ptr:], uint16(v.FieldInt16Slice[i]))
		ptr += 2
	}
	binary.LittleEndian.PutUint32(buf[ptr:], uint32(len(v.FieldUint16Slice)))
	ptr += 4
	for i := 0; i < len(v.FieldUint16Slice); i++ {
		binary.LittleEndian.PutUint16(buf[ptr:], v.FieldUint16Slice[i])
		ptr += 2
	}
	binary.LittleEndian.PutUint32(buf[ptr:], uint32(len(v.FieldCharSlice)))
	ptr += 4
	copy(buf[ptr:], []byte(v.FieldCharSlice))
	ptr += len(v.FieldCharSlice)
	binary.LittleEndian.PutUint32(buf[ptr:], uint32(len(v.FieldUint8Slice)))
	ptr += 4
	copy(buf[ptr:], []byte(v.FieldUint8Slice))
	ptr += len(v.FieldUint8Slice)
	return ptr, nil
}

func (v *Message10) Unpack(buf []byte) error {
	if len(buf) < Message10MinMsgSize {
		return fmt.Errorf("invalid buffer size for unpacking Message10: %d, should be >=%d", len(buf), Message10MinMsgSize)
	}
	ptr := 0
	{
		n := int(binary.LittleEndian.Uint32(buf[ptr:]))
		ptr += 4
		v.FieldFloat64Slice = make([]float64, n)
		for i := 0; i < n; i++ {
			v.FieldFloat64Slice[i] = math.Float64frombits(binary.LittleEndian.Uint64(buf[ptr:]))
			ptr += 8
		}
	}
	{
		n := int(binary.LittleEndian.Uint32(buf[ptr:]))
		ptr += 4
		v.FieldInt64Slice = make([]int64, n)
		for i := 0; i < n; i++ {
			v.FieldInt64Slice[i] = int64(binary.LittleEndian.Uint64(buf[ptr:]))
			ptr += 8
		}
	}
	{
		n := int(binary.LittleEndian.Uint32(buf[ptr:]))
		ptr += 4
		v.FieldUint64Slice = make([]uint64, n)
		for i := 0; i < n; i++ {
			v.FieldUint64Slice[i] = binary.LittleEndian.Uint64(buf[ptr:])
			ptr += 8
		}
	}
	{
		n := int(binary.LittleEndian.Uint32(buf[ptr:]))
		ptr += 4
		v.FieldFloat32Slice = make([]float32, n)
		for i := 0; i < n; i++ {
			v.FieldFloat32Slice[i] = math.Float32frombits(binary.LittleEndian.Uint32(buf[ptr:]))
			ptr += 4
		}
	}
	{
		n := int(binary.LittleEndian.Uint32(buf[ptr:]))
		ptr += 4
		v.FieldInt32Slice = make([]int32, n)
		for i := 0; i < n; i++ {
			v.FieldInt32Slice[i] = int32(binary.LittleEndian.Uint32(buf[ptr:]))
			ptr += 4
		}
	}
	{
		n := int(binary.LittleEndian.Uint32(buf[ptr:]))
		ptr += 4
		v.FieldUint32Slice = make([]uint32, n)
		for i := 0; i < n; i++ {
			v.FieldUint32Slice[i] = binary.LittleEndian.Uint32(buf[ptr:])
			ptr += 4
		}
	}
	{
		n := int(binary.LittleEndian.Uint32(buf[ptr:]))
		ptr += 4
		v.FieldInt16Slice = make([]int16, n)
		for i := 0; i < n; i++ {
			v.FieldInt16Slice[i] = int16(binary.LittleEndian.Uint16(buf[ptr:]))
			ptr += 2
		}
	}
	{
		n := int(binary.LittleEndian.Uint32(buf[ptr:]))
		ptr += 4
		v.FieldUint16Slice = make([]uint16, n)
		for i := 0; i < n; i++ {
			v.FieldUint16Slice[i] = binary.LittleEndian.Uint16(buf[ptr:])
			ptr += 2
		}
	}
	{
		n := int(binary.LittleEndian.Uint32(buf[ptr:]))
		ptr += 4
		v.FieldCharSlice = make([]byte, n)
		copy(v.FieldCharSlice, buf[ptr:ptr+n])
		ptr += len(v.FieldCharSlice)
	}
	{
		n := int(binary.LittleEndian.Uint32(buf[ptr:]))
		ptr += 4
		v.FieldUint8Slice = make([]uint8, n)
		copy(v.FieldUint8Slice, buf[ptr:ptr+n])
		ptr += len(v.FieldUint8Slice)
	}
	return nil
}

func (v *Message10) String() string {
	return fmt.Sprintf("<Message10 field_float64_slice=%v field_int64_slice=%v field_uint64_slice=%v field_float32_slice=%v field_int32_slice=%v field_uint32_slice=%v field_int16_slice=%v field_uint16_slice=%v field_char_slice=%v field_uint8_slice=%v>",
		v.FieldFloat64Slice, v.FieldInt64Slice, v.FieldUint64Slice, v.FieldFloat32Slice, v.FieldInt32Slice, v.FieldUint32Slice, v.FieldInt16Slice, v.FieldUint16Slice, v.FieldCharSlice, v.FieldUint8Slice)
}
